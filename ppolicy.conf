#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Configuration file for PPolicy
#
# Copyright (c) 2005 JAS
#
# Author: Petr Vokac <vokac@kmlinux.fjfi.cvut.cz>
#
# $Id$
#
import logging


#
# logging (FATAL, ERROR, WARN, INFO, DEBUG)
#
logLevel = logging.DEBUG


#
# contact in case of some problems
# (without correct values some check modules doesn't work right)
#
admin = 'postmaster@example.com' # recomended: postmaster
domain = 'example.com'     # recomended: your.domain.name, default: host.domain


#
# Database settings
#
databaseAPI = 'MySQLdb'
database = { 'host'   : 'localhost',
             'port'   : 3306,
             'db'     : 'ppolicy',
             'user'   : 'ppolicy',
             'passwd' : 'secret',
             }


#
# PPolicy daemon listen port. This port is used by Postfix
# check_policy_service.
#
ppolicyPort     = 10030
#
# PPolicy daemon command port. This port is used to manage
# and debug ppolicy daemon.
#
commandPort     = 10031


#
# Size of cache for check results. Increasing this value can lead to
# higher performance but it also uses more memory.
#
cacheSize       = 10000


#
# Define check modules and its parameters. These modules can be
# referenced by its unique name in check function.
# format: { name: (type, param), ... }
#   name ... unique module name
#   type ... module type (SPF, List, Greylist, ...)
#   param .. dictionary of module parameters, e.g. { param: "sender", ... }
#
modules = {
    'dumpfile': ('DumpDataFile', { 'fileName': '/tmp/dump.dat' }),
    'dumpdb': ('DumpDataDB', {}),
    'spf': ('SPF', {}),
    'dos': ('DOS', { 'params': 'sender' }),
    'trap': ('Trap', {}),
    'list': ('List', { 'table': 'list', 'param': 'recipient', 'column': 'key' }),
    'list_cached': ('List', { 'table': 'list', 'param': 'recipient',
                              'caseSensitive': True, 'column': 'key',
                              'cacheAll': True }),
    'list_bw': ('ListBW', { 'tableWhitelist': 'list_w',
                            'tableBlacklist': 'list_b',
                            'param': 'recipient', 'column': 'key' }),
    'list_bw_cached': ('ListBW', { 'tableWhitelist': 'list_w',
                                   'tableBlacklist': 'list_b',
                                   'param': 'recipient', 'column': 'key',
                                   'caseSensitive': False, 'cacheAll': True }),
    'list_bw_sender': ('ListMailDomain', { 'paramMailDomain': 'sender',
                                           'tableWhitelist': 'whitelist_sender',
                                           'tableBlacklist': 'blacklist_sender' }),
    'list_bw_client_address': ('ListBW', { 'param': 'client_address',
                                           'tableWhitelist': 'whitelist_client_address',
                                           'tableBlacklist': 'blacklist_client_address',
                                           'column': 'key', 'cacheAll': True }),
    'list_bw_client_name': ('ListMailDomain', { 'param': 'client_address',
                                                'tableWhitelist': 'whitelist_client_name',
                                                'tableBlacklist': 'blacklist_client_name' }),
    'verify_mx': ('Verification', { 'param': 'sender', 'vtype': 'mx' }),
    'verify_connection': ('Verification', { 'param': 'sender' }),
    'verify_domain': ('Verification', { 'param': 'sender', 'vtype': 'domain' }),
    'verify_user': ('Verification', { 'param': 'sender', 'vtype': 'user' }),
    'resolve_ip_name': ('Resolve', { 'param': 'client_address', 'type': 'ip->name' }),
    'resolve_name_ip': ('Resolve', { 'param': 'client_name', 'type': 'name->ip' }),
    'resolve_name_mx': ('Resolve', { 'param': 'client_name', 'type': 'name->mx' }),
    'resolve_ip_name_ip': ('Resolve', { 'param': 'client_address', 'type': 'ip->name->ip' }),
    'resolve_ip1_name_ip2': ('Resolve', { 'param': 'client_address', 'type': 'ip1->name->ip2' }),
    'resolve_ip_name_mx': ('Resolve', { 'param': 'client_address', 'type': 'ip->name->mx' }),
    'resolve_name_ip_name': ('Resolve', { 'param': 'client_name', 'type': 'name->ip->name' }),
    'resolve_name1_ip_name2': ('Resolve', { 'param': 'client_name', 'type': 'name1->ip->name2' }),
    'greylist': ('Greylist', {}),
    'dnsbl_ordb': ('Dnsbl', { 'dnsbl': 'ORDB' }),
    'dnsbl_njabl': ('Dnsbl', { 'dnsbl': 'NJABL' }),
    'dnsbl_sbl': ('Dnsbl', { 'dnsbl': 'SBL' }),
    'dnsbl_xbl': ('Dnsbl', { 'dnsbl': 'XBL' }),
    'dnsbl_spamcop': ('Dnsbl', { 'dnsbl': 'SPAMCOP' }),
    'dnsbl_sorbs': ('Dnsbl', { 'dnsbl': 'SORBS' }),
    'dnsbl_maps': ('Dnsbl', { 'dnsbl': 'MAPS-RBLPLUS' }),
    'dnsblscore': ('DnsblScore', {}),
    'dnsbldynamic': ('DnsblDynamic', {}),
#    '': ('', {}),
    }


#
# What to return if number of connection to ppolicy daemon reaches its limit
#
returnOnConnLimit = ('450', 'reached connection limit to ppolicy, retry later')
#returnOnFatalError = ('dunno', '')


#
# What to return when fatal error (e.g. uncatched exception) happen
#
returnOnFatalError = ('450', 'fatal error when checking SMTP data, retry later')
#returnOnFatalError = ('dunno', '')


#
# Method for checking requests
#
def check(factory, data):
    # this is similar to postfix reject_unknown_client rule, but it is
    # less restrictive, because postfix checks ip after translating
    # ip->name->ip, but here we require only existence of DNS reverse record
    #if data.get('client_name', '') == '':
    #    result '450', "we don't accept mail from domain without DNS PTR record"
    # if we want to be a bit more restrictive, we can require that reverse DNS
    # name has some A record (ip1->name->ip2), one of A record match original
    # IP address (ip->name->ip), has MX or A record (ip->name->mx)
    #res, resEx = factory.check('resolve_ip_name_mx', data)
    #if res < 0:
    #    result '450', "DNS records for %s are icorrect" % data.get('client_address')

    # here we are using greylisting but only if client_address score is higher
    # then defined treshold (6). The score is computed as sum of scores defined
    # by spamassassin for various DNS blacklist
    #res, resEx = factory.check('dnsblscore', data)
    #if res > 6:
    #    res, resEx = factory.check('greylist', data)
    #    if res < 0:
    #        result '450', resEx

    # use greylisting if client_address is probably from dynamic IP range
    # and it doesn't successfully pass SPF checking
    #res, resEx = factory.check('dnsbldynamic', data)
    #if res > 0:
    #    res, resEx = factory.check('spf', data)
    #    if spf < 0:
    #        res, resEx = factory.check('greylist', data)
    #        if res < 0:
    #            result '450', resEx

    # verify that we can contact sender by connecting its to mailserver
    #res, resEx = factory.check('verify_connection', data)
    #if res < 0:
    #    return '450', resEx

    # verify that sender exist if mail comming from suspicious client_address
    #res, resEx = factory.check('dnsblscore', data)
    #if res > 6:
    #    res, resEx = factory.check('verify_user', data)
    #    if res < 0:
    #        result '450', resE

    # use spam traps to block sites that send mail to random users
    # (this module is not fully tested - be carefull when you want to use it)
    #res, resEx = factory.check('trap', data, [ 'spamtrap1@example.com', 'spamtrap2@example.com' ])
    #if res > 0:
    #    return '450', 'you are sending too many mails to random users, slow down...'
    #elif res == DOS.CHECK_RESULT_TRAP:
    #    return '550', "this is spam trap email address, don't use it or you will be blacklisted"

    # DOS module can be used to limit number of incomming mail/time
    # You should not block mail to postmaster and from mailer-daemon
    # (this module is not fully tested - be carefull when you want to use it)
    #if data.get('sender', '') != '' and data.get('recipient', '').lower()[:11] != 'postmaster':
    #    res, resEx = factory.check('dos', data)
    #    if res < 0:
    #        return '450', 'you are sending too many mails, slow down...'

    # Reject all suspicious mail with information for sender how to
    # add his address/domain/client_address to the whitelist
    #res, resEx = factory.check('dnsblscore', data)
    #if res > 6:
    #    res, resEx = factory.check('list', data)
    #    if res < 0:
    #        return '550', "you are sending mail from suspicious address and your mail can't be delivered, if you want to pass these restrictions, you can add your address to our whitelist on following site http://www.example.com/mail/whitelist"

    # Slow down reception of suspicious mail (be carefull using this
    # method, because it can lead to DOS for all incomming SMTP requests)
    #res, resEx = factory.check('dnsblscore', data)
    #if res > 6:
    #    res, resEx = factory.check('list', data)
    #    time.sleep(5)

    # Complex example applyed only to mail with recipient address in
    # form @subdomain.example.com. If sender is not in whitelist
    # (whitelist_sender) and is not mailer-daemon, than test mail must
    # pass further tests. First we declare DNSBL score treshold
    # according results SPF, Resolve and DNS name <-> helo name
    # corespondence. Correctly configured mailserver should pass all
    # these check without problems but if some of them fail, then we
    # lower treshold for DNSBL score. If DnsblScore exceed treshold
    # then further tests are used to decide which mail we accespt or
    # reject. "Correct" DNS records are tested and "temporary failure"
    # error is returned in case this test fail. Then it is checked if
    # we can contact sender mailserver and "temporary failure" is
    # returned in the test fails. Last rule make greylisting all these
    # suspitious mails
    #if data.get('recipient', '').lower()[-len('@subdomain.example.com'):] == '@subdomain.example.com':
    #    sender_ok = False
    #    if data.get('sender', '') == '':
    #        sender_ok = True
    #    else:
    #        res, resEx = factory.check('whitelist_sender', data)
    #        sender_ok = res > 0
    #    if not sender_ok:
    #        dnsblTreshold = 5
    #        if data.get('client_name', '').lower() != data.get('helo_name', '').lower():
    #            dnsblTreshold -= 0.5
    #        res, resEx = factory.check('resolve_ip_name', data)
    #        if res < 0:
    #            dnsblTreshold -= 1
    #        res, resEx = factory.check('spf', data)
    #        if res < 0:
    #            dnsblTreshold -= 1
    #        res, resEx = factory.check('dnsblscore', data)
    #        logging.getLogger().debug("CONF: check treshold/score: %s/%s" % (dnsblTreshold, res))
    #        if res > dnsblTreshold:
    #            res, resEx = factory.check('resolve_ip_name_mx', data)
    #            if res < 0:
    #                return '450', 'Your client address is suspicious, it doesnt have correct DNS records. To whitelist your mail see http://www.example.com/mail'
    #            res, resEx = factory.check('verify_connection', data)
    #            if res < 0:
    #                return '550', 'Your client address is suspicious and your mailserver address cant be verified. To whitelist your mail see http://www.example.com/mail/'
    #            res, resEx = factory.check('greylist', data)
    #            if res < 0:
    #                wt = ''
    #                if resEx.rfind(' ') != -1:
    #                    wt = " after %s" % resEx[resEx.rfind(' '):]
    #                return '450', "Your client address is suspicious, greylist in progress, try again later%s. To whitelist your mail see http://www.example.com/mail/" % wt


    # resource usage at the beginning of check method
    import resource
#    import gc
#    gc.collect()
#    data['resource_gc_start'] = "%s, %s" % (len(gc.get_objects()), len(gc.garbage))
#    data['resource_usage_start'] = str(resource.getrusage(resource.RUSAGE_SELF))

    # tests, results are stored in 'data' dictionary, can be used for debuging
    # modules and for analysis to find new way to identify spam sources
    res, resEx = factory.check('list', data)
    res, resEx = factory.check('list_cached', data)
    res, resEx = factory.check('list_bw', data)
    res, resEx = factory.check('list_bw_cached', data)
    res, resEx = factory.check('list_bw_sender', data)
    res, resEx = factory.check('list_bw_client_address', data)
    res, resEx = factory.check('list_bw_client_name', data)
    res, resEx = factory.check('dos', data)
    res, resEx = factory.check('trap', data, [ 'spamtrap1@example.com', 'spamtrap2@example.com' ])
    res, resEx = factory.check('spf', data)
    res, resEx = factory.check('verify_connection', data)
    res, resEx = factory.check('resolve_name_mx', data)
    res, resEx = factory.check('greylist', data)
    res, resEx = factory.check('dnsbl_ordb', data)
    res, resEx = factory.check('dnsbl_xbl', data)
    res, resEx = factory.check('dnsblscore', data)
    res, resEx = factory.check('dnsbldynamic', data)

    # resource usage at the end of check method
#    gc.collect()
#    data['resource_gc_stop'] = "%s, %s" % (len(gc.get_objects()), len(gc.garbage))
#    data['resource_usage_stop'] = str(resource.getrusage(resource.RUSAGE_SELF))

    # save request info in database (e.g. for statistical owerview)
    factory.check('dumpdb', data)
    # save request info in file
    #factory.check('dumpfile', data)
    return 'dunno', ''
